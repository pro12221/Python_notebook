from python基础知识.数据类型 import stu_names

## 面向对象思想
面向过程
    核心是"过程"二字

    过程就是“流水线”，用来分步骤解决问题的

    面向过程编程的终极奥义就是在程序里造流水线

    优点：复杂的问题流程化、进而简单化

    缺点：扩展性差

面向对象
    核心是“对象”二字

    对象是一种“容器”，用来盛放数据+功能

    面向对象编程的终极奥义就是在程序造容器，整合相关的数据+功能


    优点：扩展性强

    缺点：增加了程序的复杂性

## 面向对象语法
```python
# 定义类
class student:
    school = "hello"

    def tell_info(stu):
        print("学生的名字%s,学生的年龄%s" % (stu["names"], stu["ages"]))
print(student.__dict__)

# 调用类
stu1 = student()
stu2 = student()
# print(stu1.__dict__)
# print(stu2.__dict__)
#
# # 为对象定制属性
# stu1.name="hahah"
# stu1.age="hahah"
# print(stu1.__dict__)

# 为对象初始化自己独有的属性
def init_student(obj,x,y):
    obj.name=x
    obj.age=y
init_student(stu1,1,2)
print(stu1.__dict__)

# __init__方法
# 定义类
class student:
    school = "hello"

    def __init__(obj, x, y):
        obj.name = x
        obj.age = y
    def tell_info(stu):
        print("学生的名字%s,学生的年龄%s" % (stu["names"], stu["ages"]))
print(student.__dict__)

# 调用类
stu1=student("wsa",12)
print(stu1.__dict__)

# 绑定方法
# 绑定方法
print(student.tell_info)  # <function student.tell_info at 0x0000018CEC937920>
print(stu1.tell_info)  # <bound method student.tell_info of <__main__.student object at 0x0000018C8750EE10>>

```

## 封装
```python
# 隐藏属性
class Student(object):
    __x=10

    def __init__(self,x,y):
        self.__x=111  #  私有属性（名称修饰）
        self.__y=222
print(Student._Student__x)  

#    @property方法
# class person:
    def __init__(self,name,age):
        self.__name = name
        self.__age = age
    @property
    def name(self):
        return self.__name
    def age(self):
        return self.__age
    @name.deleter
    def name(self):
        del self.__name
    @name.setter
    def name(self,name):
        self.__name = name
wsa=person("wsa",18)

wsa.name = "wsa2"
print(wsa.name)
del wsa.name
print(wsa.__dict__)

# 绑定和非绑定对象
class Person:
    def __init__(self, name):
        self.name = name

    # 实例方法（绑定方法）
    def say_hello(self):
        return f"Hello, I'm {self.name}"

    # 类方法
    @classmethod
    def class_method(cls):
        return f"This is a class method of {cls.__name__}"

    # 静态方法（非绑定方法）
    @staticmethod
    def static_method():
        return "This is a static method"

# print(Person.__dict__)

wsa=Person("wsa")
print(wsa.say_hello)
```

## 继承
```python
# 定义父类和子类
class prentclass:
    pass
class prentclass1:
    pass
class childclass(prentclass):
    pass
class childclass2(prentclass,prentclass1):
    pass
print(childclass.__bases__,childclass2.__bases__) # (<class '__main__.prentclass'>,) (<class '__main__.prentclass'>, <class '__main__.prentclass1'>)


class people:
    school="whxy"
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def get_info(self):
        print(self.name, self.age, self.school)
class teacher(people):
    pass

class student(people):
    pass

wsa=student("wsa",20)
wsa.get_info()
wsa.school="123"
wsa.get_info()
print(people.school)
```
## 菱形继承
```python
class A(object):
    def test(self):
        print('from A')
 
class B(A):
    def test(self):
        print('from B')
 
class C(A):
    def test(self):
        print('from C')
 
class D(B,C):
    pass
 
obj = D()
obj.test() # 结果为：from B
print(D.mro()) # 打印继承的顺序
```

## 派生
```python
class people:
    school="whxy"
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def get_info(self):
        print(self.name, self.age, self.school)
class teacher(people):
    # def __init__(self, name, age, school):
    #     people.__init__(self, name, age) # 这种方法查找父类
    #     self.school = school
    def __init__(self, name, age, school):
        super().__init__(name, age) # 这种方法会按照mro依次想下查找
        self.school = school
class student(people):
    pass


wsa=student("wsa",20)
wsa.get_info()
wsa.school="123"
wsa.get_info()
print(people.school)
```
## 组合
```python
class people:
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender


class courses:
    def __init__(self, name):
        self.name = name

    def tell_info(self):
        print(self.name)

    def __repr__(self):
        return f"课程('{self.name}')"


class student(people):
    def __init__(self, name, age, gender):
        super().__init__(name, age, gender)
        self.course_list = []

    def add_course(self, course):
        self.course_list.append(course)

    def show_courses(self):
        print(f"\n{self.name}的课程列表:")
        for i, course in enumerate(self.course_list, 1):
            print(f"  {i}. {course.name}")


# 使用示例
stu1 = student("wsa", 12, "male")
python = courses("Python编程")
math = courses("高等数学")
english = courses("英语")

stu1.add_course(python)
stu1.add_course(math)
stu1.add_course(english)

# 各种打印方法
print("=== 方法1: 直接打印列表 ===")
print(stu1.course_list)

print("\n=== 方法2: 显示课程详情 ===")
stu1.show_courses()

print("\n=== 方法3: 提取课程名称 ===")
course_names = [course.name for course in stu1.course_list]
print("课程名称:", course_names)

print("\n=== 方法4: 格式化输出 ===")
print(f"{stu1.name}选修了: {', '.join(course.name for course in stu1.course_list)}")
```

## 多态
```python
class animal:
    def talk(self):
        pass
class dog(animal):
    def talk(self):
        print("www")
class cat(animal):
    def talk(self):
        print("mmm")
def talk(animal):
    animal.talk()
#
cat1=cat()
dog1=dog()
talk(cat1)


import abc
 
# 指定metaclass属性将类设置为抽象类，抽象类本身只是用来约束子类的，不能被实例化
class Animal(metaclass=abc.ABCMeta):
    @abc.abstractmethod # 该装饰器限制子类必须定义有一个名为talk的方法
    def talk(self): # 抽象方法中无需实现具体的功能
        pass
 
class Cat(Animal): # 但凡继承Animal的子类都必须遵循Animal规定的标准
    def talk(self):
        pass
 
cat=Cat() # 若子类中没有一个名为talk的方法则会抛出异常TypeError，无法实例化
```
## 反射
```python
class Teacher:
    def __init__(self,full_name):
        self.full_name =full_name
 
t=Teacher('Egon Lin')
 
# hasattr(object,'name')
hasattr(t,'full_name') # 按字符串'full_name'判断有无属性t.full_name
 
# getattr(object, 'name', default=None)
getattr(t,'full_name',None) # 等同于t.full_name,不存在该属性则返回默认值None
 
# setattr(x, 'y', v)
setattr(t,'age',18) # 等同于t.age=18
 
# delattr(x, 'y')
delattr(t,'age') # 等同于del t.age
```