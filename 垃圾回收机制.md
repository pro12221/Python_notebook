# python的垃圾回收机制
解释器在执行定义变量的语法的时候会使用内存存储变量，而内存的值是有限的，当变量没用时就涉及到了垃圾回收机制
## 堆区和栈区
```
1、变量名与值内存地址的关联关系存放于栈区
2、变量值存放于堆区，内存管理回收的则是堆区的内容
```

## 直接引用和间接引用
直接引用指的是从栈区出发直接引用到的内存地址
间接引用指的是从栈区出发引用到堆区后进一步引用才能到达的内存地址
```
l2 = [20, 30]  # 列表本身被变量名l2直接引用，包含的元素被列表间接引用
x = 10  # 值10被变量名x直接引用
l1 = [x, l2]  # 列表本身被变量名l1直接引用，包含的元素被列表间接引用
```

## 垃圾回收机制原理分析
### 引用计数
引用计数就是变量值被变量名关联的次数

循环引用导致的问题
```
循环引用会导致值不被任何名字关联，但是值的引用计数不会变为0

# 如下我们定义了两个列表，简称列表1与列表2，变量名l1指向列表1，变量名l2指向列表2
>>> l1=['xxx']  # 列表1被引用一次，列表1的引用计数变为1   
>>> l2=['yyy']  # 列表2被引用一次，列表2的引用计数变为1   
>>> l1.append(l2)             # 把列表2追加到l1中作为第二个元素，列表2的引用计数变为2
>>> l2.append(l1)             # 把列表1追加到l2中作为第二个元素，列表1的引用计数变为2
 
# l1与l2之间有相互引用
# l1 = ['xxx'的内存地址,列表2的内存地址]
# l2 = ['yyy'的内存地址,列表1的内存地址]

>>> del l1 # 列表1的引用计数减1，列表1的引用计数变为1
>>> del l2 # 列表2的引用计数减1，列表2的引用计数变为1
```

### 标记-清除
```
#1、标记
通俗地讲就是：
栈区相当于“根”，凡是从根出发可以访达（直接或间接引用）的，都称之为“有根之人”，有根之人当活，无根之人当死。
具体地：标记的过程其实就是，遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），
然后将所有GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。
#2、清除
清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。
```

### 分代回收
基于引用计数的回收机制，每次回收内存都需要吧所有的对象的引用计数便利一遍，非常耗时，这时引入了分代回收
```
分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）
新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，
那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），
会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，
这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。
也就是等级（代）越高，被垃圾回收机制扫描的频率越低
```